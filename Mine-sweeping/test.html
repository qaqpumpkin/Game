<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>扫雷</title>
    <link type="text/css" rel="stylesheet" href="saolei.css">
    <style>
        .cell {
            width: 50px;
            height: 50px;
            line-height: 30px;
            display: block;
            text-align: center;
            border: solid 1px #000;
            cursor: pointer;
            float:left;
            font-size: 0
        }
        .open {
            font-size: 20px;
            background: lightgrey;!important;
        }
        .cell:hover {
            background: gray;
        }
        #id-div-mine {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateY(-50%);
            transform: translateX(-50%);
        }

        div[data-number = "0"] {
            font-size: 0px;!important;
        }
        .picture {
            max-width: 50px;
            max-height: 50px;
            line-height: 30px;
            text-align: center;
            float:none;
            display: none;
        }
        .open-picture {
            display: block;!important;
            background: url("mine.png");
            background-size:50px 50px
        }
        body{
            background: url("dog.jpg");
            overflow: auto;
            background-size:cover;
            background-repeat: no-repeat;
        }

    </style>
</head>
<body>
<script src="omit.js"></script>
<script src="random-square.js"></script>
<script>
    const log = console.log.bind(console)

    const e = function(selector) {
        let element = document.querySelector(selector)
        if (element === null) {
            let s = `选择器 ${selector} 写错了, 请仔细检查并且复习三种基本的选择器`
            alert(s)
            return null
        } else {
            return element
        }
    }

    const es = function(selector) {
        let elements = document.querySelectorAll(selector)
        if (elements.length === 0) {
            let s = `选择器 ${selector} 写错了, 请仔细检查并且复习三种基本的选择器`
            alert(s)
            return []
        } else {
            return elements
        }
    }
    const appendHtml = function(element, html) {
        element.insertAdjacentHTML('beforeend', html)
    }

    const bindEvent = function(element, eventName, callback) {
        element.addEventListener(eventName, callback)
    }

    const removeClassAll = function(className) {
        let selector = '.' + className
        let elements = es(selector)
        for (let i = 0; i < elements.length; i++) {
            let e = elements[i]
            e.classList.remove(className)
        }
    }

    const bindAll = function(selector, eventName, callback) {
        let elements = es(selector)
        for (let i = 0; i < elements.length; i++) {
            let e = elements[i]
            bindEvent(e, eventName, callback)
        }
    }

    // find 函数可以查找 element 的所有子元素
    const find = function(element, selector) {
        let e = element.querySelector(selector)
        if (e === null) {
            let s = `选择器 ${selector} 写错了, 请仔细检查并且复习三种基本的选择器`
            alert(s)
            return null
        } else {
            return e
        }
    }

    const closestClass = function(element, className) {
        /*
        element 是一个 DOM 元素
        className 是一个 string
        循环查找 element 的直系父元素
        如果父元素拥有 className 这个 class, 则返回这个父元素
        body 的 parentElement 是 html，html 的 parentElement 是 null
        如果找到最上面的元素都还没有找到（也就是找到 html 的 parentElement）, 则返回 null
        */
        let e = element
        while (e !== null) {
            if (e.classList.contains(className)) {
                return e
            } else {
                e = e.parentElement
            }
        }
        // 如果找到最上面都没有找到, 直接返回 null
        return null
    }

    // 实现 closestId 函数
    const closestId = function(element, idName) {
        /*
        element 是一个 DOM 元素
        idName 是一个 string
        循环查找 element 的直系父元素
        如果父元素拥有 idName 这个 id, 则返回这个父元素
        body 的 parentElement 是 html，html 的 parentElement 是 null
        如果找到最上面的元素都还没有找到（也就是找到 html 的 parentElement）, 则返回 null

        提示
        假设 a 是一个标签, 用 a.id 来获取它的 id
        直接复制并且修改前面作业的代码
        */
        let e = element
        while (e !== null) {
            if (e.id === idName) {
                return e
            } else {
                e = e.parentElement
            }
        }
        // 如果找到最上面都没有找到, 直接返回 null
        return null
    }

    const closestTag = function(element, tagName) {
        /*
        element 是一个 DOM 元素
        tagName 是一个 string
        循环查找 element 的直系父元素
        如果父元素是一个 tagName 标签, 则返回这个父元素
        body 的 parentElement 是 html，html 的 parentElement 是 null
        如果找到最上面的元素都还没有找到（也就是找到 html 的 parentElement）, 则返回 null


        tagName 是 'div' 'p' 'h1' 这样的标签名
        获取一个 DOM 元素的标签名的方法如下
        element.tagName
        需要注意的是, tagName 属性返回的标签名是大写的
        例如 'DIV' 'H1'
        所以你在比较的时候需要把 tagName 转换为大写字母
        使用如下 js 标准库函数转换
        tagName.toUpperCase()

        直接复制并且修改前面作业的代码
        */
        let e = element
        while (e !== null) {
            if (e.tagName.toUpperCase() === tagName.toUpperCase()) {
                return e
            } else {
                e = e.parentElement
            }
        }
        // 如果找到最上面都没有找到, 直接返回 null
        return null
    }

    const closest = function(element, selector) {
        /*
        element 是一个 DOM 元素
        selector 是一个 string, 表示一个选择器
        可能的值是  'div'  '#id-div-gua'  '.red' 这三种

        循环查找 element 的直系父元素
        如果父元素符合选择器, 则返回这个父元素
        body 的 parentElement 是 html，html 的 parentElement 是 null
        如果找到最上面的元素都还没有找到（也就是找到 html 的 parentElement）, 则返回 null

        提示
        判断选择器的第一个字符来决定如何比较
        直接复制并且修改前面作业的代码
        */
        let c = selector[0]
        if (c === '#') {
            let idName = selector.slice(1)
            let r = closestId(element, idName)
            return r
        } else if (c === '.') {
            let className = selector.slice(1)
            let r = closestClass(element, className)
            return r
        } else {
            let r = closestTag(element, selector)
            return r
        }

        // 常见错误写法
        // for (let i = 0; i < array.length; i++) {
        //     if (array[i] > 0) {
        //         return a
        //     } else {
        //         return false
        //     }
        // }
    }

    const clonedArray = function(array) {
        let l = []
        l = array.slice(0)
        return l
    }
    const clonedSquare = function(array) {
        let l = []
        for (let i = 0; i < array.length; i++) {
            l.push(clonedArray(array[i]))
        }
        return l
    }

    const markedSquare = function(array) {
        let square = []
        square = clonedSquare(array)
        let row = square.length
        let list = square[0].length
        return markAround(square, row, list)
    }
    const Add = function (a) {
        if (a == 9) {
            return 9
        } else {
            return  a + 1
        }
    }

    const markAround = function (array, row, list) {
        let l = []
        l = clonedSquare(array)
        for (let i = 0; i < row; i++) {
            for (let j = 0; j < list; j++) {
                // 四个角
                if (l[i][j] == 9 && i === 0 && j === 0) {
                    l[i][j + 1] = Add(l[i][j + 1])
                    l[i + 1][j] = Add(l[i + 1][j])
                    // 右下
                    l[i + 1][j + 1] = Add(l[i + 1][j + 1])
                } else if (l[i][j] == 9 && i === (row - 1) && j === 0) {
                    l[i][j + 1] = Add(l[i][j + 1])
                    l[i - 1][j] = Add(l[i - 1][j])
                    // 右上
                    l[i - 1][j + 1] = Add(l[i - 1][j + 1])
                } else if (l[i][j] == 9 && i === 0 && j === (list - 1)) {
                    l[i][j - 1] = Add(l[i][j - 1])
                    l[i + 1][j] = Add(l[i + 1][j])
                    // 左下
                    l[i + 1][j - 1] = Add(l[i + 1][j - 1])
                } else if (l[i][j] == 9 && i === (row - 1) && j === (list - 1)) {
                    l[i][j - 1] = Add(l[i][j - 1])
                    l[i - 1][j] = Add(l[i - 1][j])
                    // 左上
                    l[i - 1][j - 1] = Add(l[i - 1][j - 1])
                    // 四条边
                } else if (l[i][j] == 9 && i === 0) {
                    l[i][j - 1] = Add(l[i][j - 1])
                    l[i][j + 1] = Add(l[i][j + 1])
                    l[i + 1][j] = Add(l[i + 1][j])
                    // 上边：需要左下和右下
                    l[i + 1][j + 1] = Add(l[i + 1][j + 1])
                    l[i + 1][j - 1] = Add(l[i + 1][j - 1])
                } else if (l[i][j] == 9 && i === (row - 1)) {
                    l[i][j - 1] = Add(l[i][j - 1])
                    l[i][j + 1] = Add(l[i][j + 1])
                    l[i - 1][j] = Add(l[i - 1][j])
                    // 下边：需要左上和右上
                    l[i - 1][j - 1] = Add(l[i - 1][j - 1])
                    l[i - 1][j + 1] = Add(l[i - 1][j + 1])
                } else if (l[i][j] == 9 && j === (list - 1)) {
                    l[i + 1][j] = Add(l[i + 1][j])
                    l[i - 1][j] = Add(l[i - 1][j])
                    l[i][j - 1] = Add(l[i][j - 1])
                    // 右边：需要左上和左下
                    l[i - 1][j - 1] = Add(l[i - 1][j - 1])
                    l[i + 1][j - 1] = Add(l[i + 1][j - 1])
                } else if (l[i][j] == 9 && j === 0) {
                    l[i + 1][j] = Add(l[i + 1][j])
                    l[i - 1][j] = Add(l[i - 1][j])
                    l[i][j + 1] = Add(l[i][j + 1])
                    // 左边：需要右上和右下
                    l[i + 1][j + 1] = Add(l[i + 1][j + 1])
                    l[i - 1][j + 1] = Add(l[i - 1][j + 1])
                } else if (l[i][j] == 9) {
                    l[i + 1][j] = Add(l[i + 1][j])
                    l[i - 1][j] = Add(l[i - 1][j])
                    l[i][j + 1] = Add(l[i][j + 1])
                    l[i][j - 1] = Add(l[i][j - 1])
                    l[i - 1][j - 1] = Add(l[i - 1][j - 1])
                    l[i + 1][j - 1] = Add(l[i + 1][j - 1])
                    l[i + 1][j + 1] = Add(l[i + 1][j + 1])
                    l[i - 1][j + 1] = Add(l[i - 1][j + 1])
                }
            }
        }
        return l
    }

    // 实现扫雷程序的流程如下
    // 1, 生成扫雷数据
    // 2, 根据扫雷数据画图
    // 3, 点击的时候根据情况判断
    //      因为展开的时候需要对周围的数字进行处理, 所以最好能在地图上记录下标
    //
    // 为了方便, 我们跳过第一步, 直接用下面给定的数据即可, 这样方便测试
    // 直接写死数据
    // let s = ' [[9,1,0,0,0,1,1,1,0],[1,1,0,0,1,2,9,1,0],[1,1,1,0,1,9,2,1,0],[1,9,2,1,1,1,1,0,0],[1,2,9,1,0,0,1,1,1],[1,2,1,1,0,1,2,9,1],[9,1,0,0,1,2,9,2,1],[1,2,1,1,1,9,2,1,0],[0,1,9,1,1,1,1,0,0]]'
    // 把字符串转成数组
    // let square = JSON.parse(s)

    // 以我们这个数据为例, 网页布局实际上应该 9 * 9 的格子
    // cell 用 float 完成布局, clearfix 是用来解决浮动的方案
    // 每一行处理成下面的形式
    // data-number 是数字, data-x 和 data-y 分别是数组中的下标
    // data-x="0" data-y="3" 表示 square[0][3], 也就是第 1 行第 4 列的格子
    // <div class="row clearfix">
    //     <div class="cell" data-number="9" data-x="0" data-y="0">9</div>
    //     <div class="cell" data-number="1" data-x="0" data-y="1">1</div>
    //     <div class="cell" data-number="0" data-x="0" data-y="2">0</div>
    //     <div class="cell" data-number="0" data-x="0" data-y="3">0</div>
    //     <div class="cell" data-number="0" data-x="0" data-y="4">0</div>
    //     <div class="cell" data-number="1" data-x="0" data-y="5">1</div>
    //     <div class="cell" data-number="1" data-x="0" data-y="6">1</div>
    //     <div class="cell" data-number="1" data-x="0" data-y="7">1</div>
    //     <div class="cell" data-number="0" data-x="0" data-y="8">0</div>
    // </div>
    const random = function () {
        let n = Math.random()
        n = n * 9
        n = Math.floor(n)
        return n % 4
    }
    const randomLine = function (n) {
        let l = []
        for (let i = 0; i < n; i++) {
            let e = random()
            if(e === 1){
                l.push(9)
            } else {
                l.push(0)
            }
        }
        return l
    }
    const randomSquare = function (n) {
        let l = []
        for (let i = 0; i < n; i++) {
            let e = randomLine(n)
            l.push(e)
        }
        return l
    }
    // 1. templateCell 函数, 参数为数组 line 和变量 x, x 表示第几行
    // 返回 line.length 个 cell 拼接的字符串
    const templateCell = function(line, x) {
        let str = ''
        for (let i = 0; i < line.length; i++) {
            let n = line[i]
            str += `<div class="cell" data-number="${n}" data-x="${x}" data-y="${i}">` + `${n}` + '</div>'
        }
        return str
    }

    // 2. templateRow 的参数 square 是二维数组, 用来表示雷相关的数据
    // 返回 square.length 个 row 拼接的字符串
    // row 的内容由 templateCell 函数生成
    const templateRow = function(square) {
        let str = ''
        for (let i = 0; i < square.length; i++) {
            str += '<div class="row clearfix">'
            str += templateCell(square[i], i)
            str += '</div>'
        }
        return str
    }

    // 3. square 是二维数组, 用来表示雷相关的数据
    // 用 square 生成 9 * 9 的格子, 然后插入到页面中
    // div container 是 <div id="id-div-mime"></div>
    const renderSquare = function(square) {
        let body = e('body')
        body.insertAdjacentHTML('beforeend', '<div id="id-div-mine"></div>')
        let mine = e('#id-div-mine')
        mine.insertAdjacentHTML('beforeend', templateRow(square))
    }

    // 4. 实现 bindEventDelegate 函数, 只处理格子, 也就是 .cell 元素
    const bindEventDelegate = function() {
        let mine = es('div[data-number = "9"]')
        for (let i = 0; i < mine.length; i++) {
            let e = mine[i]
            e.insertAdjacentHTML('afterbegin', '<img class="picture" src="mine.png" alt="flag">')
        }
    }

    // 5. vjkl 是点击格子的函数
    // 要注意的是我们在初始情况下就把数字写到了 html 中
    // <div class="cell" data-number="1" data-x="0" data-y="1">1</div>
    // 而初始情况下数字不应该显示出来的, 可以直接用 font-size: 0; 来隐藏文字
    // 点击的时候根据情况用 font-size: 14px;
    // (当然这一步应该用 class 来完成, 比如添加 opened class) 的方式显示文字
    // 如果已经显示过, 则不做任何处理
    // 如果没有显示过, 判断下列情况
    // 1. 如果点击的是 9, 展开, 游戏结束
    // 2. 如果点击的是 0, 展开并且调用 vjklAround 函数
    // 3. 如果点击的是其他数字, 展开
    const vjkl = function(square) {
        bindAll('.cell', 'click', function(event) {
            log('点击 tag')
            let self = event.target

            if (self.dataset.number == 9) {
                let img = es('img')
                for (let i = 0; i < img.length; i++) {
                    let e = img[i]
                    e.classList.add('open-picture')
                }
                let all = document.querySelectorAll('.cell')
                for (let i = 0; i < all.length; i++) {
                    let e = all[i]
                    e.classList.add('open')
                }
                alert('游戏结束')
            } else if(self.dataset.number == 0){
                let x = self.dataset.x
                let y = self.dataset.y
                x = Number(x)
                y = Number(y)
                vjklAround(square, x, y)
            } else {
                self.classList.add('open')
            }
        })
    }

    // 6. vjklAround 展开周围 cell 周围 8 个元素,
    // x 和 y 分别是下标
    // 展开周围的元素通过调用 vjkl1 来解决
    const vjklAround = function(square, x, y) {
        vjkl1(square, x - 1, y - 1)
        vjkl1(square, x, y - 1)
        vjkl1(square, x + 1, y - 1)
        // 标记上下 2 个
        vjkl1(square, x - 1, y)
        vjkl1(square, x + 1, y)
        // 标记右边 3 个
        vjkl1(square, x - 1, y + 1)
        vjkl1(square, x, y + 1)
        vjkl1(square, x + 1, y + 1)
    }
    const judge = function (line, number) {
        for (let i = 0; i < line.length; i++) {
            if(number === line[i]) {
                return false
            } else {
                continue
            }
        }
        return true
    }
    // 7. vjkl1 是重点函数
    // 如果满足边界调节, 则继续
    // 因为 vjkl1 这个函数是展开格子, 所以如果已经展开过, 那么就不展开元素
    // 根据 x 和 y 还有属性选择器选择出格子, 具体可以参考
    // https://developer.mozilla.org/zh-CN/docs/Web/CSS/Attribute_selectors
    // 如果没有展开过, 判断下列情况
    // 如果碰到的是 9, 什么都不做.
    // 注意, 这里 9 的处理方式和直接点击格子 9 的处理方式不一样
    // 如果碰到的是 0, 递归调用 vjklAround 函数
    // 如果碰到的是其他元素, 展开
    const vjkl1 = function(square, x, y) {
        let n = square.length
        let line = []
        if (x >= 0 && x < n && y >= 0 && y < n) {
            let a = e(`div[data-x = "${x}"][data-y = "${y}"]`)
            let num = `${x}${y}`
            if(!a.classList.contains('open') && judge(line, num)){
                if(a.dataset.number == 0){
                    line.push(num)
                    a.classList.add('open')
                    vjklAround(square, x, y)
                } else if(a.dataset.number !== 9){
                    line.push(num)
                    a.classList.add('open')
                }
            }
        }
    }
    const __main = function() {
        let square = []
        square = randomSquare(9)
        square = markAround(square,9 ,9)
        log(square)
        renderSquare(square)
        bindEventDelegate()
        vjkl(square)
    }
    __main()

</script>
</body>
</html>